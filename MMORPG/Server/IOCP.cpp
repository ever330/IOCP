#include "IOCP.h"
#include "MainServer.h"
#include "Packet.h"

void IOCP::Initialize()
{
	WSADATA wsaData;

	SOCKADDR_IN serverAddr;
	int recvBytes, i, flags = 0;

	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
		std::cout << "WSAStartup Error" << std::endl;

	SOCKET listenSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

	if (listenSocket == INVALID_SOCKET)
	{
		std::cerr << "서버 소켓 생성 실패: " << WSAGetLastError() << std::endl;
		closesocket(listenSocket);
		WSACleanup();
		return;
	}

	memset(&serverAddr, 0, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serverAddr.sin_port = htons(PORT);

	bind(listenSocket, (sockaddr*)&serverAddr, sizeof(serverAddr));
	listen(listenSocket, 5);

	// IOCP 생성
	m_hIocp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

	if (m_hIocp == NULL)
	{
		std::cerr << "CreateIoCompletionPort failed with error: " << WSAGetLastError() << std::endl;
		WSACleanup();
		return;
	}

	std::cout << "서버 시작" << std::endl;

	m_serverSession = new Session;
	m_serverSession->socket = listenSocket;
	m_serverSession->sockAddr = serverAddr;

	int nZero = 0;
	int nRet = setsockopt(listenSocket, SOL_SOCKET, SO_SNDBUF, (char*)&nZero, sizeof(nZero));

	if (nRet == SOCKET_ERROR)
	{
		std::cerr << "setsockopt(SNDBUF) 실패: " << WSAGetLastError() << std::endl;
		return;
	}

	// Worker Thread 생성
	for (int i = 0; i < _Thrd_hardware_concurrency() - CONTENTS_THREAD; ++i)
	{
		m_workerThreads.emplace_back(std::thread(&IOCP::WorkerThread, this));
	}

	for (auto& worker : m_workerThreads)
	{
		worker.detach();
	}

	CreateIoCompletionPort((HANDLE)listenSocket, m_hIocp, 0, 0);

	lpfnAcceptEx = NULL;
	GuidAcceptEx = WSAID_ACCEPTEX;
	DWORD dwBytes;

	int result = WSAIoctl(listenSocket, SIO_GET_EXTENSION_FUNCTION_POINTER,
		&GuidAcceptEx, sizeof(GuidAcceptEx),
		&lpfnAcceptEx, sizeof(lpfnAcceptEx),
		&dwBytes, NULL, NULL);

	if (result == SOCKET_ERROR)
	{
		std::cerr << "WSAIoctl 실패: " << WSAGetLastError() << std::endl;
		closesocket(listenSocket);
		WSACleanup();
		return;
	}

	m_nextSessionID = 1;

	std::shared_ptr<IOData> ioData = std::make_shared<IOData>();
	memset(&ioData->overlapped, 0, sizeof(OVERLAPPED));
	ioData->mode = ACCEPT;
	ioData->packetMemory = std::shared_ptr<char[]>(new char[LOCAL_ADDR_SIZE + REMOTE_ADDR_SIZE + 16]);
	ioData->wsaBuf.buf = ioData->packetMemory.get();
	ioData->wsaBuf.len = LOCAL_ADDR_SIZE + REMOTE_ADDR_SIZE + 16;

	{
		std::lock_guard<std::mutex> lock(m_ioMapMutex);
		m_ioDataMap[&ioData->overlapped] = ioData;
	}

	bool postResult = PostAccept(ioData);

	if (!postResult)
	{
		return;
	}
}

void IOCP::Finalize()
{
	for (auto& thread : m_workerThreads)
		PostQueuedCompletionStatus(m_hIocp, 0, 0, nullptr);

	for (auto& thread : m_workerThreads)
		thread.join();

	if (m_hIocp)
		CloseHandle(m_hIocp);

	for (auto& session : m_sessions)
	{
		closesocket(session.second->socket);
		delete session.second;
	}

	closesocket(m_serverSession->socket);
	delete m_serverSession;
}

void IOCP::SendPacket(unsigned int sessionID, std::shared_ptr<char[]> packet, int byteLength)
{
	auto it = m_sessions.find(sessionID);
	if (it == m_sessions.end())
	{
		std::cerr << "세션 ID를 찾을 수 없습니다: " << sessionID << std::endl;
		return;
	}

	std::shared_ptr<IOData> writeIoData = std::make_shared<IOData>();
	memset(&writeIoData->overlapped, 0, sizeof(OVERLAPPED));
	std::shared_ptr<char[]> buffer(new char[byteLength]);
	memcpy(buffer.get(), packet.get(), byteLength);
	writeIoData->packetMemory = buffer;
	writeIoData->wsaBuf.buf = writeIoData->GetBuffer();
	writeIoData->wsaBuf.len = byteLength;
	writeIoData->mode = WRITE;

	{
		std::lock_guard<std::mutex> lock(m_ioMapMutex);
		m_ioDataMap[&writeIoData->overlapped] = writeIoData;
	}

	DWORD bytesSent = 0;
	int result = WSASend(it->second->socket, &(writeIoData->wsaBuf), 1, &bytesSent, 0, &(writeIoData->overlapped), NULL);
	if (result == SOCKET_ERROR)
	{
		int error = WSAGetLastError();
		if (error != WSA_IO_PENDING)
		{
			std::cerr << "WSASend 실패, error: " << error << std::endl;
			return;
		}
	}
	return;
}

void IOCP::BroadCast(std::shared_ptr<char[]> packet, int byteLength)
{
	for (auto& session : m_sessions)
	{
		std::shared_ptr<IOData> writeIoData = std::make_shared<IOData>();
		memset(&writeIoData->overlapped, 0, sizeof(OVERLAPPED));
		writeIoData->packetMemory = std::shared_ptr<char[]>(new char[byteLength]);
		writeIoData->packetMemory = packet;
		writeIoData->wsaBuf.buf = writeIoData->GetBuffer();
		writeIoData->wsaBuf.len = byteLength;
		writeIoData->mode = WRITE;

		{
			std::lock_guard<std::mutex> lock(m_ioMapMutex);
			m_ioDataMap[&writeIoData->overlapped] = writeIoData;
		}

		DWORD bytesSent;
		if (session.second->socket != INVALID_SOCKET)
		{
			WSASend(session.second->socket, &(writeIoData->wsaBuf), 1, &bytesSent, 0, &(writeIoData->overlapped), NULL);
		}
		else
		{
			std::cerr << "세션 소켓이 유효하지 않습니다: " << session.first << std::endl;
			EraseSession(session.first);
		}
	}
}

void IOCP::UpdateHeartBeatTime(unsigned int sessionID)
{
	auto it = m_sessions.find(sessionID);
	if (it != m_sessions.end())
	{
		it->second->lastHeartbeatTime = std::chrono::steady_clock::now();
	}
	else
	{
		std::cerr << "세션 ID를 찾을 수 없습니다: " << sessionID << std::endl;
	}
}

bool IOCP::PostAccept(std::shared_ptr<IOData> ioData)
{
	SOCKET clientSocket = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);

	if (clientSocket == INVALID_SOCKET)
	{
		std::cerr << "클라이언트 소켓 생성 실패: " << WSAGetLastError() << std::endl;
		return false;
	}

	// 클라이언트 컨텍스트 할당 및 초기화
	Session* client = new Session;
	client->socket = clientSocket;

	ioData->session = client;
	memset(&ioData->overlapped, 0, sizeof(OVERLAPPED));
	ioData->mode = ACCEPT;

	DWORD dwBytes;

	bool result = lpfnAcceptEx(m_serverSession->socket, client->socket, ioData->GetBuffer(),
		0,
		LOCAL_ADDR_SIZE, REMOTE_ADDR_SIZE,
		&dwBytes, &(ioData->overlapped));

	if (!result)
	{
		int error = WSAGetLastError();
		if (error != WSA_IO_PENDING) // WSA_IO_PENDING(997)이 아니면 실패 처리
		{
			std::cerr << "AcceptEx 실패: " << error << std::endl;
			closesocket(clientSocket);
			delete client;

			return false;
		}
	}

	return true;
}

bool IOCP::PostRecv(Session* session, std::shared_ptr<IOData> ioData)
{
	memset(&ioData->overlapped, 0, sizeof(OVERLAPPED));
	ioData->wsaBuf.buf = ioData->GetBuffer();
	ioData->wsaBuf.len = BUFFER_SIZE;
	ioData->mode = READ;

	DWORD flags = 0;
	DWORD bytesReceived;
	int result = WSARecv(session->socket, &ioData->wsaBuf, 1, &bytesReceived, &flags, &ioData->overlapped, NULL);

	if (result == SOCKET_ERROR && WSAGetLastError() != WSA_IO_PENDING)
	{
		closesocket(session->socket);
		delete session;
		m_ioDataMap.erase(&ioData->overlapped);

		return false;
	}
	return true;
}

void IOCP::EraseSession(unsigned int sessionID)
{
	std::lock_guard<std::mutex> lock(m_mutex);

	for (auto it = m_ioDataMap.begin(); it != m_ioDataMap.end();)
	{
		if (it->second->sessionID == sessionID)
			it = m_ioDataMap.erase(it);
		else
			++it;
	}

	auto it = m_sessions.find(sessionID);
	if (it != m_sessions.end())
	{
		closesocket(it->second->socket);
		delete it->second;
		m_sessions.erase(it);

		MainServer::Instance().DisconnectClient(sessionID);
		// 세션 ID 재사용을 위해 큐에 추가
		//m_availableSessionIDs.push(sessionID);
	}
}

unsigned int IOCP::GenerateSessionID()
{
	/*std::lock_guard<std::mutex> lock(m_mutex);
	std::cout << "Before check: empty = " << m_availableSessionIDs.empty() << std::endl;
	if (!m_availableSessionIDs.empty())
	{
		unsigned int reusedID = m_availableSessionIDs.front();
		m_availableSessionIDs.pop();
		return reusedID;
	}*/
	return m_nextSessionID++;
}

void IOCP::HeartBeatThread()
{
	while (true)
	{
		std::this_thread::sleep_for(std::chrono::milliseconds(HEARTBEAT_INTERVAL_MS));

		auto now = std::chrono::steady_clock::now();

		std::lock_guard<std::mutex> lock(m_mutex); // 세션 접근 동기화  

		for (auto& sessionPair : m_sessions)
		{
			unsigned int sessionID = sessionPair.first;
			Session* session = sessionPair.second;

			// 타임아웃 체크  
			auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(now - session->lastHeartbeatTime);
			if (duration.count() > TIMEOUT_MS)
			{
				// 응답 없음: 연결 종료 처리  
				EraseSession(sessionID);
				continue;
			}

			// 하트비트 패킷 전송  
			SendHeartBeat(sessionID);
		}
	}
}

void IOCP::SendHeartBeat(unsigned int sessionID)
{
	int packetSize = sizeof(PacketBase);

	// 패킷 메모리 할당
	std::shared_ptr<char[]> buffer(new char[packetSize]);

	// 패킷 생성
	PacketBase* packet = reinterpret_cast<PacketBase*>(buffer.get());
	packet->PacketSize = packetSize;
	packet->PacID = PacketID::S2CHeartBeat;

	// 패킷 전송
	SendPacket(sessionID, buffer, packetSize);
}

void IOCP::WorkerThread()
{
	DWORD bytesTransferred;
	Session* session;
	OVERLAPPED* overlapped;
	DWORD flags = 0;

	while (true)
	{
		BOOL success = GetQueuedCompletionStatus(
			m_hIocp,
			&bytesTransferred,
			(PULONG_PTR)&session,
			&overlapped,
			INFINITE
		);

		std::shared_ptr<IOData> ioData;
		{
			std::lock_guard<std::mutex> lock(m_ioMapMutex);
			auto it = m_ioDataMap.find(overlapped);
			if (it != m_ioDataMap.end()) {
				ioData = it->second;
				m_ioDataMap.erase(it);  // 처리 완료 후 제거
			}
		}

		if (!success || (bytesTransferred == 0 && ioData->mode != ACCEPT))
		{
			std::cout << "클라이언트 연결 종료" << std::endl;
			if (session)
			{
				EraseSession(session->sessionID);
			}
			continue;
		}

		if (ioData->mode == ACCEPT)
		{
			Session* curSession = ioData->session;

			unsigned int sessionID = GenerateSessionID();
			curSession->sessionID = sessionID;
			curSession->lastHeartbeatTime = std::chrono::steady_clock::now();

			setsockopt(curSession->socket, SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT, (char*)&m_serverSession->socket, sizeof(m_serverSession->socket));

			int size = sizeof(SOCKADDR_IN);
			SOCKADDR_IN curSockAddrIn;
			memset(&curSockAddrIn, 0x00, sizeof(curSockAddrIn));

			getpeername(curSession->socket, (struct sockaddr*)&curSockAddrIn, &size);

			char szip[64] = { 0 };

			if (InetNtopA(AF_INET, &(&curSockAddrIn)->sin_addr, szip, INET_ADDRSTRLEN) == NULL)
			{
				std::cerr << "IP 변환 실패" << std::endl;
				return;
			}

			std::cout << "클라이언트 IP: " << szip << " 접속" << std::endl;

			CreateIoCompletionPort((HANDLE)curSession->socket, m_hIocp, (ULONG_PTR)curSession, 0);

			m_sessions[sessionID] = curSession;

			std::shared_ptr<IOData> newIoData = std::make_shared<IOData>();
			memset(&newIoData->overlapped, 0, sizeof(OVERLAPPED));
			newIoData->mode = READ;
			newIoData->packetMemory = std::shared_ptr<char[]>(new char[LOCAL_ADDR_SIZE + REMOTE_ADDR_SIZE + 16]);
			newIoData->wsaBuf.buf = ioData->packetMemory.get();
			newIoData->wsaBuf.len = LOCAL_ADDR_SIZE + REMOTE_ADDR_SIZE + 16;

			{
				std::lock_guard<std::mutex> lock(m_ioMapMutex);
				m_ioDataMap[&newIoData->overlapped] = newIoData;
			}

			bool recvResult = PostRecv(curSession, newIoData);
			if (!recvResult)
			{
				std::cerr << "PostRecv() 실패!" << std::endl;
				delete curSession;
				m_sessions.erase(sessionID);
				break;
			}

			// 다음 클라이언트의 연결 요청을 받기 위해 PostAccept() 호출
			m_ioDataMap[&ioData->overlapped] = ioData;
			bool postResult = PostAccept(ioData);
			if (!postResult)
			{
				std::cerr << "PostAccept() 실패!" << std::endl;
				break;
			}
		}
		else if (ioData->mode == READ)
		{
			ioData->wsaBuf.len = bytesTransferred;
			ioData->mode = READ;

			MainServer::Instance().PushData(session->sessionID, ioData->GetBuffer());

			m_ioDataMap[&ioData->overlapped] = ioData;
			bool recvResult = PostRecv(session, ioData);
			if (!recvResult)
			{
				std::cerr << "PostRecv() 실패!" << std::endl;
				break;
			}
		}
		else if (ioData->mode == WRITE)
		{

		}
	}
}